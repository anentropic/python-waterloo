{-# LANGUAGE TupleSections #-}

module Waterloo (main) where

import Control.Applicative (empty)
import Control.Monad (void)
import Data.Void (Void)
import Data.Char (isAlphaNum)
import System.Environment (getArgs)
import Text.Megaparsec (
  takeWhile1P, -- Parse one or more tokens for which the supplied predicate holds
  parseTest, -- applies the parser `p` against input `input` and prints the result to stdout
  eof, -- This parser only succeeds at the end of the input.
  try, -- `try p` behaves like parser `p`, except that it backtracks the parser state when `p` fails
  (<?>), -- A synonym for `label` in the form of an operator.
  Parsec, -- [parsec]
  sepBy1) -- [parsec] parses one or more occurrences of `p`, separated by `sep`. Returns a list of values returned by `p`.
import Text.Megaparsec.Char (
  space1) -- Skip one or more white space characters.
import qualified Text.Megaparsec.Char.Lexer as L


type Parser = Parsec Void String


-- parser that matches comments beginning with #
lineComment :: Parser ()
lineComment = L.skipLineComment "#"

-- parser which matches whitespace, including newline
scn :: Parser ()
scn = L.space space1 lineComment empty

-- parser which only matches ' ' and '\t', not newlines
sc :: Parser ()
sc = L.space (void $ takeWhile1P Nothing f) lineComment empty
  where
    f x = x == ' ' || x == '\t'

-- curry L.lexeme applying our space-consumer `sc`
lexeme :: Parser a -> Parser a
lexeme = L.lexeme sc

-- parser matching lexemes matching [a-zA-Z0-9\-]+
pItem :: Parser String
pItem = lexeme (takeWhile1P Nothing f) <?> "list item"
  where
    f x = isAlphaNum x || x == '-'

-- parser 
pLineFold :: Parser String
pLineFold = L.lineFold scn $ \sc' -> -- <newline-whitespace> <callback>
  -- "The second argument is a callback that receives a custom space-consuming parser as argument."
  -- ...this space-consumer is generated by L.lineFold internals, to handle indentation
  let ps = takeWhile1P Nothing f `sepBy1` try sc'
      f x = isAlphaNum x || x == '-'
        -- takeWhile1P <label for tokens> <predicate> -> <list of tokens> 
        --    <predicate> here is: f `sepBy1` try sc'
        --    `sepBy1` ...backticks use function as infix operator
        --    basically... one or more <like pItem> sepBy <line-fold whitespace>
  in unwords <$> ps <* sc
  -- `let ... in <expr>` defines values for use in <expr>
  -- `unwords` is like " ".join(List[str])
  --    <$> operator: "lifts a single-argument function into a Functor"
  --        (aka 'infix fmap'... I guess here acting on `unwords`)
  --        basically `a <$> b` applies a to b
  --    <* operator: Sequence actions, discarding the value of the second argument.
  --        `u <* v = liftA2 const u v`
  --        `const x <anything>` always returns `x` i.e. f = const(x) ... f(<anything>) == x
  --        liftA2 "lifts a binary [i.e. two arg] function across two Applicative Functors"
  --  TODO: I don't know why `ps <* sc` and not just `ps`
  --    maybe related to L.lineFold "for the last symbol we use normal space consumer"
  --    or need to consume trailing space?
  --    --> I think yes, to consume the trailing space
  --    --> this is also why we use <f `sepBy1` try sc'> above... because lineFold callback
  --        should use sc' for all but the last item, then regular sc for the last
  -- so...
  -- here we are...
  -- taking a list of pItem-like tokens found at current-or-greater indent
  -- and joining them with ' '

-- parser matching list item and its indented children
pComplexItem :: Parser (String, [String])
pComplexItem = L.indentBlock scn p -- <whitepace> <'reference' token>
  where
    p = do
      header <- pItem -- i.e. parent
      return (L.IndentMany Nothing (return . (header, )) pLineFold)
      -- L.IndentMany <indent level> <how to get result> <indented token parser>

-- parser matching a collection of list items, begins non-indented, ends non-indented
-- i.e. a whole list
pItemList :: Parser (String, [(String, [String])])
pItemList = L.nonIndented scn (L.indentBlock scn p)
  where
    p = do
      header <- pItem
      return (L.IndentSome Nothing (return . (header, )) pComplexItem)
      -- "return is not a keyword in Haskell. It is an overloaded function
      -- that 'lifts' a value into a monadic wrapper"
      -- "It's called return because when you're writing out monads in do
      -- notation, it looks like what you'd do in a C-like language."
      --
      --  (return . (header, ))
      --          ^ the `.` means 'function composition' i.e.
      -- `f . g x` means `f(g(x))`
      --
      -- and the (header, ) is 'TupleSections' syntax sugar returning a
      -- function: \x -> (header, x)
      -- i.e. accepts args to fill in 'missing' elements (here a single element
      -- after the trailing comma)
      --
      -- so... here we... provide a function which takes an anonymous arg and
      -- returns (header, x)

-- document is a collection of lists
parser :: Parser (String, [(String, [String])])
parser = pItemList <* eof


main = do
    input <- fmap head getArgs  -- get first (`head`) cli arg
    parseTest parser input
