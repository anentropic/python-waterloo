#!/usr/bin/env python
import argparse
import logging
import re
import sys
from functools import partial

from megaparsy import char
from megaparsy.char.lexer import (
    indent_block,
    space,
    lexeme as megaparsy_lexeme,
    IndentMany,
    IndentSome,
    line_fold,
)
from megaparsy.control.applicative.combinators import between
import parsy

logging.basicConfig(level=logging.DEBUG)


# UTILS

# parser which matches whitespace, including newline
scn = space(char.space1)

# parser which only matches ' ' and '\t', but *not* newlines
_space_no_nl = parsy.regex(r'( |\t)*').result('')
_space1_no_nl = parsy.regex(r'( |\t)+').result('')
_non_space = parsy.regex(r'\S')
sc = space(_space1_no_nl)

# factory for parser returning tokens separated by no-newline whitespace
lexeme = partial(megaparsy_lexeme, p_space=sc)

rest_of_line = parsy.regex(r'.*')  # without DOTALL this will stop at a newline


# SECTION HEADERS

# "Kwargs" is not official part of Napoleon but gets used by mistake
args_section_name = parsy.regex('Args|Kwargs').result('Args')

args_head = args_section_name << parsy.string(':') << (_space_no_nl + char.eol)

returns_section_name = parsy.regex('Returns|Yields')

returns_head = returns_section_name << parsy.string(':') << (_space_no_nl + char.eol)


# PYTHON IDENTIFIERS

# a python var name
var_name = lexeme(parsy.regex(r'\*{0,2}[a-zA-Z]\w*'))

# a dotted import path to a var name
dotted_var_path = lexeme(parsy.regex(r'[a-zA-Z][\w\.]*'))


@parsy.generate
def _nested():
    return (
        yield between(
            parsy.regex(r'\[\s*'),
            parsy.regex(r',?\s*\]'),  # allow line-breaks and trailing-comma
            type_def.sep_by(parsy.regex(r',\s*')),  # includes new-lines
        )
    )


_type_token = dotted_var_path | parsy.string('...')

# mypy type definition, parsed into its nested components
type_def = parsy.seq(_type_token, _nested) | _type_token | _nested

# in "Args" section the type def is in parentheses after the var name
arg_type_def = lexeme(
    parsy.string('(') >> type_def << parsy.regex(r'\)\:?')
)

arg_type = parsy.seq(arg=var_name, type=arg_type_def.optional())  # seq kwargs needs Py 3.6+

# in "Returns" section the type def is bare and there is no var name, optional description
# (description is not part of Napoleon spec but it's natural to provide one)
return_type = type_def << parsy.regex(r'\:?')


# SECTION PARSERS

def _line_fold_callback(sc_):
    """
    A 'line fold' is a follow-on line which is part of an indented item
    (See `line_fold` from megaparsy)

    Args:
        sc_: this space-consumer is generated by line_fold internals
            to handle indentation
    """
    @parsy.generate
    def _line_fold_callback_inner():
        """
        folded lines are the wrapped description for an arg
        """
        p_folded = ((_non_space + rest_of_line) << sc_)
        folded = yield p_folded.at_least(1)
        return folded

    return _line_fold_callback_inner << sc


p_line_fold = line_fold(scn, _line_fold_callback)


def indented_items(p_arg_item):
    """
    Factory returning parser to consume the items within a section
    """

    @parsy.generate
    def _indented_items():
        head = yield p_arg_item
        # in this case the `head` is the part of the item we care about
        # and `tail` is be the folded arg description, we discard it
        return IndentMany(indent=None, f=lambda _: head, p=p_line_fold)

    return _indented_items


def section(p_section_name, p_arg_items):
    """
    Factory returning parser to consume a section and its indented items
    """

    @parsy.generate
    def _args_list_block():
        head = yield p_section_name << parsy.string(':') << _space_no_nl
        return IndentSome(
            indent=None,
            f=lambda tail: {'name': head, 'items': tail},
            p=p_arg_items,
        )

    return _args_list_block


p_arg_list = indent_block(
    scn,
    section(
        args_section_name,
        indent_block(scn, indented_items(arg_type << rest_of_line))
    )
)

p_returns_block = indent_block(
    scn,
    section(
        returns_section_name,
        indent_block(scn, indented_items(return_type << rest_of_line))
    )
)


# consume any line that is not a section head that we care about (Args / Returns)
ignored_line = (
    (_space_no_nl >> (args_head | returns_head)).should_fail('not section head') >>
    rest_of_line >>
    char.eol
).result('')


# THE PARSER
docstring_parser = (
    parsy.seq(
        args=ignored_line.many() >> p_arg_list,
        returns=ignored_line.many() >> p_returns_block,
    )
    << parsy.regex(r'.*', re.DOTALL)
)


if __name__ == "__main__":
    cli_arg_parser = argparse.ArgumentParser()
    cli_arg_parser.add_argument(
        'file_to_parse',
        default=sys.stdin,
        type=argparse.FileType('r'),
        nargs='?',
    )
    cli_args = cli_arg_parser.parse_args()

    input_ = cli_args.file_to_parse.read()
    # print(input_)

    val = docstring_parser.parse(input_)
    print(val)
