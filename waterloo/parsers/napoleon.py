#!/usr/bin/env python
import argparse
import re
import sys
from functools import partial

from megaparsy import char
from megaparsy.char.lexer import (
    indent_block,
    space,
    lexeme as megaparsy_lexeme,
    IndentMany,
    IndentSome,
    line_fold,
    non_indented,
)
from megaparsy.utils import try_
import parsy


# parser which matches whitespace, including newline
scn = space(char.space1)

# parser which only matches ' ' and '\t', but *not* newlines
_space_no_nl = parsy.regex(r'( |\t)*').result('')
_space1_no_nl = parsy.regex(r'( |\t)+').result('')
sc = space(_space1_no_nl)

# factory for parser returning tokens separated by no-newline whitespace
lexeme = partial(megaparsy_lexeme, p_space=sc)


section_name = parsy.regex('Args|Kwargs')

args_head = section_name << parsy.string(':') << (_space_no_nl + char.eol)

var_name = lexeme(parsy.regex(r'[a-zA-Z]\w*'))

type_def = lexeme(
    parsy.string('(') >> parsy.regex(r'[^)]+') << parsy.regex(r'\)\:?')
)

arg_type = parsy.seq(arg=var_name, type=type_def)  # needs Py 3.6+

rest_of_line = parsy.regex(r'.*')  # without DOTALL this will stop at a newline


_token = parsy.regex(r'[a-zA-Z0-9\-]+')
p_item_factory = partial(lexeme, _token)
p_item = p_item_factory().desc('list')


# sub-lists
def _line_fold_callback(sc_):
    """
    "The second argument to `line_fold` is a callback that receives a
     custom space-consuming parser as argument."

    Args:
        sc_: this space-consumer is generated by line_fold internals
            to handle indentation
    """
    @parsy.generate
    def _line_fold_callback_inner():
        """
        My understanding of the Haskell original of this callback is:
        taking a list of `p_item`-like tokens found at current-or-greater
        indent and joining them with ' '
        """
        items = yield megaparsy_lexeme(_token, p_space=sc_).at_least(1)
        return ' '.join(items)

    return _line_fold_callback_inner << sc


p_line_fold = line_fold(scn, _line_fold_callback)


@parsy.generate
def _complex_item_block():
    header = yield p_item
    return IndentMany(indent=None, f=lambda val: (header, val), p=p_line_fold)


# parser matching list item and its indented children
p_complex_item = indent_block(scn, _complex_item_block)


@parsy.generate
def _args_list_block():
    """
    return (L.IndentSome Nothing (return . (header, )) pComplexItem)

    (return . (header, ))
            ^ means 'function composition'
    """
    header = yield p_item
    return IndentSome(indent=None, f=lambda val: (header, val), p=p_complex_item)


# consume lines until an `args_head` is reached
ignored_line = (
    (_space_no_nl >> args_head).should_fail('not `args_head`') >>
    rest_of_line >>
    char.eol
).result('')

p_arg_list = non_indented(scn, indent_block(scn, _args_list_block))


args_parser = p_arg_list << parsy.regex(r'.*', re.DOTALL)


if __name__ == "__main__":
    cli_arg_parser = argparse.ArgumentParser()
    cli_arg_parser.add_argument(
        'file_to_parse',
        default=sys.stdin,
        type=argparse.FileType('r'),
        nargs='?',
    )
    cli_args = cli_arg_parser.parse_args()

    input_ = cli_args.file_to_parse.read()
    # print(input_)

    val = args_parser.parse(input_)
    print(val)
