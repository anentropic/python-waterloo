#!/usr/bin/env python
import argparse
import logging
import re
import sys
from functools import partial

from megaparsy import char
from megaparsy.char.lexer import (
    indent_block,
    space,
    lexeme as megaparsy_lexeme,
    IndentMany,
    IndentSome,
    line_fold,
)
from megaparsy.utils import try_, debug
import parsy

logging.basicConfig(level=logging.DEBUG)


# parser which matches whitespace, including newline
scn = space(char.space1)

# parser which only matches ' ' and '\t', but *not* newlines
_space_no_nl = parsy.regex(r'( |\t)*').result('')
_space1_no_nl = parsy.regex(r'( |\t)+').result('')
_non_space = parsy.regex(r'\S')
sc = space(_space1_no_nl)

# factory for parser returning tokens separated by no-newline whitespace
lexeme = partial(megaparsy_lexeme, p_space=sc)


section_name = parsy.regex('Args|Kwargs').result('Args')

args_head = section_name << parsy.string(':') << (_space_no_nl + char.eol)

var_name = lexeme(parsy.regex(r'[a-zA-Z]\w*'))

type_def = lexeme(
    parsy.string('(') >> parsy.regex(r'[^)]+') << parsy.regex(r'\)\:?')
)

arg_type = parsy.seq(arg=var_name, type=type_def)  # kwargs needs Py 3.6+

rest_of_line = parsy.regex(r'.*')  # without DOTALL this will stop at a newline

# consume any line that is not an `args_head`
ignored_line = (
    (_space_no_nl >> args_head).should_fail('not `args_head`') >>
    rest_of_line >>
    char.eol
).result('')


p_arg_item = arg_type << rest_of_line


def _line_fold_callback(sc_):
    """
    "The second argument to `line_fold` is a callback that receives a
     custom space-consuming parser as argument."

    Args:
        sc_: this space-consumer is generated by line_fold internals
            to handle indentation
    """
    @parsy.generate
    def _line_fold_callback_inner():
        """
        folded lines are the wrapped description for an arg
        """
        p_folded = ((_non_space + rest_of_line) << sc_)
        folded = yield p_folded.at_least(1)
        return folded

    return _line_fold_callback_inner << sc


p_line_fold = line_fold(scn, _line_fold_callback)


@parsy.generate
def _arg_items_block():
    head = yield p_arg_item
    # in this case the 'tail' would be the folded arg description
    return IndentMany(indent=None, f=lambda _: head, p=p_line_fold)


p_arg_items = indent_block(scn, _arg_items_block)


@parsy.generate
def _args_list_block():
    head = yield section_name << parsy.string(':') << _space_no_nl
    return IndentSome(indent=None, f=lambda tail: (head, tail), p=p_arg_items)


p_arg_list = indent_block(scn, _args_list_block)


args_parser = p_arg_list << parsy.regex(r'.*', re.DOTALL)


if __name__ == "__main__":
    cli_arg_parser = argparse.ArgumentParser()
    cli_arg_parser.add_argument(
        'file_to_parse',
        default=sys.stdin,
        type=argparse.FileType('r'),
        nargs='?',
    )
    cli_args = cli_arg_parser.parse_args()

    input_ = cli_args.file_to_parse.read()
    # print(input_)

    val = args_parser.parse(input_)
    print(val)
